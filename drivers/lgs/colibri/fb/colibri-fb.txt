Colibri frame-buffer driver
===========================
Michael Brandt
v0.1 2015-01-14
// asciidoc source. http://www.methods.co.nz/asciidoc
// :toc:
// :icons:
// :numbered:

== Kernel configuration ==

The driver needs physical contiguous memory which is allocated with
dma_alloc_coherent().
For this CONFIG_CMA in the kernel configuration must be set.

    CONFIG_CMA=y
    CONFIG_CMA_DEBUG=y

    #
    # Default contiguous memory area size:
    #
    CONFIG_CMA_SIZE_MBYTES=32
    CONFIG_CMA_SIZE_SEL_MBYTES=y
    # CONFIG_CMA_SIZE_SEL_PERCENTAGE is not set
    # CONFIG_CMA_SIZE_SEL_MIN is not set
    # CONFIG_CMA_SIZE_SEL_MAX is not set
    CONFIG_CMA_ALIGNMENT=8
    CONFIG_CMA_AREAS=7


== Driver entry points ==

The driver supports only memory mapped frame buffers. Therefore it has no
read() entry point.

=== open/close ===

Every camera must be opened by its corresponding minor device, e.g.
'/dev/colibri_fb0', '/dev/colibri_fb1' and so on.

DMA (frame-buffer) memory allocated by the corresponding ioctl will be freed
upon close.

=== ioctl ===

IO controls are used to allocate DMA buffer, to start a capture and to
retrieved capture information.

Since the cameras are multiplexed and we have only one DMA controller, only
one capture can be started at a time.

=== mmap ===

Map the previously allocated DMA/frame buffer into user space.
The memory range will be non-cached.

=== poll ===

After the capture (DMA) was started, poll()/select() should be used to wait
until the buffer is filled.

The driver poll routine adds a waitqueue which is woken up by the DMA interrupt
handler.
There is only one waitqueue for all minor devices (cameras), since we can
handle we multiplexed cameras only one by one.
If the DMA transfer was already done, when poll() is called (irq_count > 0),
it will set the returned mask accordingly (POLLIN | POLLRDNORM).

=== intr ===

The (DMA) interrupt handler clears the DMA interrupt and set the transferred
bytes count in the capture info structure of the current minor device (the
device which started the DMA).
The interrupt handler increments the interrupt counter and wakes up the
waitqueue.


== Usage ==

. Open the device, e.g. /dev/colibri_fb0

    fd = open("/dev/colibri_fb0", O_RDWR);

. Allocate a DMA (frame) buffer with the COL_IOC_FB_ALLOC ioctl.

    col_fb_alloc.size = FB_SIZE;
    ret = ioctl(fd, COL_IOC_FB_ALLOC, &col_fb_alloc);

. Map the DMA buffer with mmap() into the user space.

    fb_addr = mmap(NULL, col_fb_alloc.size, PROT_READ | PROT_WRITE,
                   MAP_SHARED, fd, col_fb_alloc.offset);

. Make the camera settings via i2c.

. Start the capture with the COL_IOC_CAPTURE ioctl.

    ret = ioctl(fd, COL_IOC_CAPTURE, col_fb_alloc.offset);

. Wait with select()/poll() until the buffer is filled.

    /* Watch framebuffer to see when it has input. */
    FD_ZERO(&rfds);
    FD_SET(fd, &rfds);

    /* Wait up to five seconds. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(fd + 1, &rfds, NULL, NULL, &tv);


. Retrieve the capture info, transferred bytes, status, etc. with the
COL_IOC_CAPINFO ioctl.

    ioctl(fd, COL_IOC_CAPINFO, &capinfo);
    debug("capinfo.bytesused %d (0x%x)\n",
            capinfo.bytesused, capinfo.bytesused);


. Save data to file

    bindump(out_fd, fb_addr, capinfo.bytesused);

// vim: set syntax=asciidoc fileencoding=utf-8 ff=unix:
