Colibri EDM driver (Electronic Distance Measurement)
====================================================
Michael Brandt
v0.1 2015-04-05
// asciidoc source. http://www.methods.co.nz/asciidoc
// :toc:
// :icons:
// :numbered:

== Kernel configuration ==


== Driver entry points ==

The driver supports only memory mapped DMA buffers. Therefore it has no
read() entry point.

=== open/close ===

There is only one device, i.e. no other minor devices.
The device can be opened by its corresponding name under /dev, e.g.
'/dev/colibri_edm'.

DMA (frame-buffer) memory allocated by the corresponding ioctl will be freed
upon close.

=== ioctl ===

IO controls are used to allocate DMA buffer, to start a capture and to
retrieved capture information.

Two DMA buffers will be used. The user application must
copy the data in time and enqueue the buffer as fast as possible.

=== mmap ===

Map the previously allocated DMA/frame buffer into user space.
The memory range will be non-cached.

=== poll ===

After the capture (DMA) was started, poll()/select() should be used to wait
until the buffer is filled.

The driver poll routine adds a waitqueue which is woken up by the DMA interrupt
handler.
If the DMA transfer was already done when poll() is called (irq_count > 0),
it will set the returned mask accordingly (POLLIN | POLLRDNORM).

=== intr ===

The (DMA) interrupt handler clears the DMA interrupt and set the transferred
bytes count in the capture info structure of the current minor device (the
device which started the DMA).
The interrupt handler increments the interrupt counter and wakes up the
waitqueue.


== Usage ==

. Open the device, e.g. /dev/colibri_edm

    fd = open("/dev/colibri_edm", O_RDWR);

. Allocate two DMA (frame) buffer with the COL_IOC_FB_ALLOC ioctl.

    col_fb_alloc_1.size = FB_SIZE;
    ret = ioctl(fd, COL_IOC_FB_ALLOC, &col_fb_alloc_1);
    col_fb_alloc_2.size = FB_SIZE;
    ret = ioctl(fd, COL_IOC_FB_ALLOC, &col_fb_alloc_2);

. Map the DMA buffer with mmap() into the user space.

    fb_addr_1 = mmap(NULL, col_fb_alloc.size, PROT_READ | PROT_WRITE,
                   MAP_SHARED, fd, col_fb_alloc_1.offset);

    fb_addr_2 = mmap(NULL, col_fb_alloc.size, PROT_READ | PROT_WRITE,
                   MAP_SHARED, fd, col_fb_alloc_2.offset);

. Start the capture with the COL_IOC_CAPTURE ioctl.

    ret = ioctl(fd, COL_IOC_CAPTURE, col_fb_alloc_1.offset);

Push the second DMA descriptor in the descriptor queue:

    ret = ioctl(fd, COL_IOC_CAPTURE, col_fb_alloc_2.offset);

. Wait with select()/poll() until the buffer is filled.

    /* Watch DMA buffer to see when it has input. */
    FD_ZERO(&rfds);
    FD_SET(fd, &rfds);

    /* Wait up to five seconds. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(fd + 1, &rfds, NULL, NULL, &tv);


. Retrieve the capture info, transferred bytes, status, etc. with the
COL_IOC_CAPINFO ioctl.

    ioctl(fd, COL_IOC_CAPINFO, &capinfo);
    debug("capinfo.bytesused %d (0x%x)\n",
            capinfo.bytesused, capinfo.bytesused);


. Save data to file

    bindump(out_fd, fb_addr_1, capinfo.bytesused);

. Start again the capture for the first buffer

. Wait for the second buffer

. Save data from second buffer

. Start again the capture for the second buffer

// vim: set syntax=asciidoc fileencoding=utf-8 ff=unix:
