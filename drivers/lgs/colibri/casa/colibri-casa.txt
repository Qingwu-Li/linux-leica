Colibri casa driver (angle determination)
=========================================
Michael Brandt
v0.1 2015-02-10
// asciidoc source. http://www.methods.co.nz/asciidoc
// :toc:
// :icons:
// :numbered:

== Kernel configuration ==


== Driver entry points ==

The driver supports only memory mapped DMA buffers. Therefore it has no
read() entry point.

=== open/close ===

There is only one device, i.e. no other minor devices.
The device can be opened by its corresponding name under /dev, e.g.
'/dev/colibri_casa'.

DMA (frame-buffer) memory allocated by the corresponding ioctl will be freed
upon close.

=== ioctl ===

IO controls are used to allocate DMA buffer, to start a capture and to
retrieved capture information.

The same DMA buffer will be re-used. The user application must
copy the data in time.

=== mmap ===

Map the previously allocated DMA/frame buffer into user space.
The memory range will be non-cached.

=== poll ===

After the capture (DMA) was started, poll()/select() should be used to wait
until the buffer is filled.

The driver poll routine adds a waitqueue which is woken up by the DMA interrupt
handler.
If the DMA transfer was already done when poll() is called (irq_count > 0),
it will set the returned mask accordingly (POLLIN | POLLRDNORM).

=== intr ===

The (DMA) interrupt handler clears the DMA interrupt and set the transferred
bytes count in the capture info structure of the current minor device (the
device which started the DMA).
The interrupt handler increments the interrupt counter and wakes up the
waitqueue.


== Usage ==

. Open the device, e.g. /dev/colibri_casa

    fd = open("/dev/colibri_casa", O_RDWR);

. Allocate a DMA (frame) buffer with the COL_IOC_FB_ALLOC ioctl.

    col_fb_alloc.size = FB_SIZE;
    ret = ioctl(fd, COL_IOC_FB_ALLOC, &col_fb_alloc);

. Map the DMA buffer with mmap() into the user space.

    fb_addr = mmap(NULL, col_fb_alloc.size, PROT_READ | PROT_WRITE,
                   MAP_SHARED, fd, col_fb_alloc.offset);


. Start the capture with the COL_IOC_CAPTURE ioctl.

    ret = ioctl(fd, COL_IOC_CAPTURE, col_fb_alloc.offset);

. Wait with select()/poll() until the buffer is filled.

    /* Watch DMA buffer to see when it has input. */
    FD_ZERO(&rfds);
    FD_SET(fd, &rfds);

    /* Wait up to five seconds. */
    tv.tv_sec = 5;
    tv.tv_usec = 0;

    retval = select(fd + 1, &rfds, NULL, NULL, &tv);


. Retrieve the capture info, transferred bytes, status, etc. with the
COL_IOC_CAPINFO ioctl.

    ioctl(fd, COL_IOC_CAPINFO, &capinfo);
    debug("capinfo.bytesused %d (0x%x)\n",
            capinfo.bytesused, capinfo.bytesused);


. Save data to file

    bindump(out_fd, fb_addr, capinfo.bytesused);

// vim: set syntax=asciidoc fileencoding=utf-8 ff=unix:
